los switches operan en capa 2
payload maximo permitido es 1500bytes

ethernet opera en capa fisica y data link.
en data link se encuentan 2 subcapas(sublayers):
- LLC -> se comunica con las capas superiores (IPv4 o IPv6 por ejemplo) y con el hardware en las capas inferiores.
- MAC -> 
	- data encapsulation: 
		- ethernet frame
		- ethernet addressing (source and destination MAC addresses)
		- ethernet error detection with frame check secuence (FCS trailer)
	- accessing the media: **incluye las especificaciones para diferentes estandares de comunicacion ethernet a traves de distintos tipos de medios fisicos**. Hoy en dia ethernet operan en full-duplex pero Ethernet en half-duplex usa [[CSMA-CD]].

### local area networks (LAN)
- estan separadas por routers, no switches
- es una red contenida en un area pequena como un piso de oficina
- se usan routers para conectar distintas LANs

## ethernet frame(capa 2)
el tamano minimo de un frame son **64 bytes** y el maximo son **1518 bytes**
- 64 bytes - 18 bytes (header + trailer size) = 46 bytes
- entonces el tamano minimo de un payload son 46 bytes
- en caso de que el payload sea menor a 46 bytes, se agregan bytes de padding
un frame ethernet mayor a **1500 bytes es consierado un jumbo frame**

partes que lo componen:
![[Pasted image 20260115181550.png]]
el preamble y SFD *no se consideran parte del header*
preamble: 
- 7 bytes (56 bits)
- alterna 1's y 0's
- 10101010 * 7
- permite a los dispositivos sincronizar sus clocks
SFD (start frame delimiter):
- 1 byte (8 bits)
- 10101011
- marca el final del preamble y el comienzo del resto del frame

***campos del header:***
destination y source:
- indica los dispositivos enviando y recibiendo el frame
- consisten del 'MAC address' del emisor y del receptor
- MAC = media access control
- 6 byte (48-bit) tamano de la direccion del dispositivo fisico

type:
- 2 byte/16-bit
- si su valor es >=1536(0x0600) se interpreta como **type**, sino se interpreta como **length**
- dice que protocolo viaja dentro (IPv4, IPv6, ARP)
- 0x0800 IPv4
- 0x86DD IPv6
length:
- si su valor es <=1500 se interpreta como **length**, sino se interpreta como **type**
![[Pasted image 20260115182702.png]]

***campo del trailer:***
FCS (frame check sequence):
- 4 bytes (32 bits) de largo
- detecta datos corrompidos al correr un algoritmo "CRC" a los datos recibidos
	- CRC = 'cyclic redundancy check'


###### = 26 bytes (header + trailer)

### direcciones MAC
- 6 bytes(48-bits) direccion fisica asignada al dispositivo cuando se lo fabrica
	- 'burned-in address' (BIA)
- es globalmente unica
- los **primeros 3 bytes son el OUI** (organizationally unique identifier), el cual es asignado a la compania creando el dispositivo
- los **ultimos 3 bytes son unicos al dispositivo en si mismo**
- se escribe como 12 caracteres hexadecimales
- cada switch tiene una tabla de direcciones MAC
	- si el switch no conoce la direccion de un frame ethernet hace un FLOOD de este en todas sus interfaces, menos en la que recibio el frame
![[Pasted image 20260216061703.png]]

#### direcciones aprendidas dinamicamente
se aprenden automaticamente por switches desde el trafico de la red (con [[CCNA/notes/resources/ARP]])
- son removidas de la tabla luego de 5 min de inactividad en switches Cisco
#### direcciones aprendidas estaticamente
son configuradas manualmente para dispositivos especificos, estas proveen mayor seguridad o control dado que nunca expiran y tienen mayor prioridad

---
dentro de un paquete IP se encuentran los campos:
- src IP: 192.168.1.1
- dst IP: 192.168.1.3
- src MAC: .9D00 por ejemplo.
- dst MAC: ???
para conocer la direccion MAC del destinatario se utilizan paquetes del tipo [[CCNA/notes/resources/ARP]] y en IPv6 [[neighbor discovery]]
se envia con una direccion de destination = FFFF.FFFF.FFFF que es la direccion broadcast en MAC

para verificar si dos dispositivos se pueden conectar entre si se usa [[ping]]

### tipo de trafico con direcciones MAC
- unicast: un frame es enviado por un unico dispositivo transmisor a un unico dispositivo. Para conocer direcciones de destino MAC es usado: IPv4 -> ARP; IPv6 neighbor discovery.
- broadcast: un frame es recibido y procesado por todos los dispositivos en la LAN ethernet:
	- direccion MAC FF-FF-FF-FF-FF-FF
	- flood en todos los puertos de switches ethernet excepto por el que recibe
	- *routers no hacen forwarding de estos frames*
	- si los datos encapsulados fuera un paquete IPv4, la direccion de destino del paquete sera 1.1.1.1. *no siempre se envia un paquete IPv4 en un ethernet broadcast*. En IPv6 utiliza multicast como si fuera broadcast.
	
#### multicast
este frame es recibido y procesado por un grupo de dispositivos en la LAN ethernet que pertenecen al mismo grupo multicast
	- **destino MAC 01-00-5E cuando los datos encapsulados son un paquete IPv4 multicast**
	- **destino MAC 33-33 cuando los datos encapsulados son un paquete IPv6 multicast**
	- tambien hay otras direcciones MAC multicast reservadas para cuando los datos no son IP, como para STP y LLDP
	- si un switch no esta configurado para multicast snooping, flood en todos los puertos del switch, excepto por el que recibe
si los datos encapsulados son un paquete IP multicast, los dispositivos pertenecientes al grupo seran asignados **direcciones IPv4 desde 224.0.0.0 a 239.257.257.257. El rango en direcciones IPv6 comienza por ff00::/8**

la direccion MAC multicast se calcula a partir de los campos de direccion IP de destino

### MAC address table
tambien conocida como content addressable memory (CAM) table.
*MAC address table es donde un switch examina para decidir por donde reenviar frames*

**MAC learning**
cada frame que entra al switch es analizado en busqueda de direccion MAC de origen y asociandolo a su numero de puerto del switch correspondiente. 
- Si la direccion de origen MAC no esta registrada en la tabla, se anade junto al numero de puerto del switch. 
- En caso de que la direccion MAC de origen si exista, el switch actualiza el timer para esa entrada (por default las entradas en la tabla duran 5 minutos)
- si ya existe la entrada para esa direccion MAC pero por un puerto distinto, se actualizara el timer y el numero de puerto al mas actualizado

**frame forwarding**
si el switch recibe un frame unicast y hay un match en la direccion MAC de destino del frame y una entrada en el address table se reenviara en frame en el puerto especificado. Si la direccion MAC de destino no esta en la tabla **se hara flood del frame por todos los puertos excepto por el que lo recibio**

es decir:
- si la direccion MAC destino del frame esta en la tabla y el puerto asociado es distinto al que recibe el frame -> la reenvia solo al puerto asociado a esa direccion
- si la direccion MAC destino del frame esta asociada al mismo puerto que recibe el frame -> se descarta el frame porque son parte del mismo "cable"
- si la direccion MAC destino no esta en la tabla se hace flood por todos los puertos menos por el que lo recibe

en Cisco IOS:
show mac address-table

borrar direcciones dinamicas de la tabla -> clear mac address-table dynamic

borrar direcciones dinamicas de un tabla especifica-> clear mac address-table dynamic address  < mac-address > 
![[Pasted image 20260122064617.png]]

## metodos de forwarding en switches Cisco:
store-and-forward switching: el switch recibe el frame entero y computa el CRC para detectar errores. Si el CRC es valido, el switch busca la direccion de destino, que determinara por que interfaz sera reenviado el paquete. Luego el frame es reenviado en el puerto correcto

cut-through switching: El switch lee la direccion MAC de destino y reenvia el frame antes de que sea recibido completamente.
- fast-forward switching: con menor nivel de latencia, se envia inmediatamente luego de leer la direccion de destino. *Es mas propenso a errores y es el metodo tipico cuando se usa cut-through switching*
- fragment-free switching: **el switch almacena los primeros 64 bytes antes de reenviar.** Es un punto medio entre cut-through y store-and-forward. Analiza solo los primeros 64 bytes porque es donde es mas propenso a errores, hace un pequeno analisis de errores en esta primera parte del frame.

## buffering en switches
port-based memory: 
- una memoria es asignada a cada puerto. Se usan filas asociadas con puertos de entrada y salida, donde si un puerto se queda sin memoria esos frames seran descartados. Funciona mejor en ambientes con trafico predicible.
	- si un puerto esta ocupado, los frames esperan en la fila y un frame lento puede bloquear a los demas (head-of-line blocking)


shared memory: 
- todos los frames son puestos en un buffer de memoria compartida por todos los puertos del switch. La cantidad de memoria buffer es alocada dinamicamente.
	- los frames son asignados a puertos de destino dinamicamente.

shared memory puede guardar frames mas grandes y descartar menos frames.

## duplex y configuracion de velocidad
es importante que las configuraciones de duplex y de ancho de banda sean iguales entre el puerto del switch y al dispositivo conectado

**la autonegociacion** es una funcion opcional que permite a dos dispositivos negociar automaticamente la mejor velocidad disponible y capacidades de duplex

duplex mismatch es un error comun que causa errores de rendimiento en links ethernet 10/100. Ocurre cuando un *puerto del link opera en half-duplex y el otro en full-duplex*

## [[auto MDI-X]]
automatic medium-dependent interface crossover
cuando esta disponible, el switch detecta automaticamente el tipo de cable en el puerto y configua las interfaces acordemente.

auto MDI-X es disponible por default en switches corriendo Cisco IOS ReleaseÂ 12.2(18)SE o mas recientes